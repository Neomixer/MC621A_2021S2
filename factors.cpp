#include <bitset>
#include <vector>
using namespace std;

typedef long long ll;
typedef vector<int> vi;

//related functions are in repository
ll _sieve_size;
bitset<10000010> bs; //10^7 should be enough for most cases
vi primes; //compact list of primes in form of vector<int>

void sieve(ll upperbound) { //create list of primes in [0..upperbound]
	_sieve_size = upperbound + 1; //add 1 to include upperbound
	bs.set(); //set all bits to 1
	bs[0] = bs[1] = 0; // except index 0 and 1
	for (ll i = 2; i <= _sieve_size; i ++) if (bs[i]) {
		//cross out multiples of i starting from i * i
		for (ll j = i * i; j <= _sieve_size; j += i) bs [j] = 0;
		primes.push_back((int)i); //also add this vector containing list of primes
	}
} //call this method in main method

bool isPrime(ll N) { // a good enough deterministic prime tester
	if (N <= _sieve_size) return bs [N]; // O(1) for small primes
	for (int i = 0; i < (int) primes.size(); i ++)
		if (N % primes[ i ] == 0 ) return false;
	return true; //it takes longer time if N is a large prime
} //note : only work for N <= (last prime in vi "primes" ) ^2

vi primeFactors(ll N) { //remember : vi is vector of integers, ll is long long
	vi factors; //vi primes (generated by sieve) is optional
	ll PF_idx = 0, PF = primes [PF_idx]; //using PF = 2, 3, 4, ... is also ok
	while (N != 1 && (PF * PF <= N) ) { // stop at sqrt (N), but N can get smaller
		while (N % PF == 0) { N /= PF; factors.push_back(PF); } //remove this PF
		PF = primes [++PF_idx]; //only consider primes
	}
	if (N != 1) factors.push_back(N); //special case if N is actually a prime
	return factors; //if pf exceeds 32âˆ’bit integer, you have to change vi
}

int gcd (int a, int b) { return b == 0 ? a : gcd(b, a % b); }

int lcm (int a, int b) { return a * (b / gcd(a, b)); }

ll EulerPhi(ll N) {
	ll PF_idx = 0, PF = primes[PF_idx], ans = N; //start from ans = N
	while (N != 1 && (PF * PF <= N)) {
		if (N % PF == 0) ans -= ans / PF; //only count unique f a c t o r
		while (N % PF == 0) N /= PF;
		PF = primes[++PF_idx];
	}
	if (N != 1) ans -= ans / N; //last factor
	return ans;
}